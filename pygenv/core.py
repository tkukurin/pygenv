"""Wraps global environment maintenance."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['info', 'tell', 'ProcResult', 'sprun', 'GlobalEnv', 'env_make_activate', 'cli']

# %% ../nbs/00_core.ipynb 3
from functools import partial
import os
from pprint import pformat
import sys
from pathlib import Path
import subprocess as sproc

import subprocess
from dataclasses import dataclass, field


# informational vs output data
# e.g. `tell` is meant to be piped or consumed by another script
# `info` is just hack to replace logging
info = partial(print, file=sys.stderr)
tell = lambda *a: print(*a) if any(a) else None


@dataclass
class ProcResult:
    ok: bool
    out: str
    err: str
    raw: sproc.CompletedProcess = field(repr=False)


def sprun(*args, **kwargs) -> ProcResult:
    result = subprocess.run(
        map(str, args),
        capture_output=True,
        text=False,  # Keep raw output as bytes
        **kwargs
    )
    return ProcResult(
        ok=result.returncode == 0,
        out=result.stdout.decode('utf-8', errors='replace').strip() if result.stdout else "",
        err=result.stderr.decode('utf-8', errors='replace').strip() if result.stderr else "",
        raw=result,
    )


class GlobalEnv:
    """instance of a globally managed environment
    """

    BASE = Path("~/tk/uv").expanduser() 

    def __init__(self, name: str):
        self.name = name
        self.path = self.BASE / name

    def activate_path(self, shell = None) -> Path:
        shell = shell or os.path.basename(os.getenv('SHELL', '/bin/bash'))
        for n, activate_file in ({
            'bash': 'activate',
            'zsh': 'activate',
            'fish': 'activate.fish',
            'csh': 'activate.csh',
        }).items():
            if shell.startswith(n):
                break  # fix for "fishlogin"
        return self.path / "bin" / activate_file
    
    def validate(env):
        feats = dict(
            has_root = env.path.exists(),
            has_activate = env.activate_path.exists(),
            has_py = (env.path / "bin" / "python").exists(),
            py = sprun(
                str(env.path / "bin" / "python"),
                "--version"
            ).out,
        )
        is_valid = all(v for k, v in feats.items() if k.startswith("has"))
        return is_valid, feats


def env_make_activate(name: str):
    outs = None
    env = GlobalEnv(name)

    if env.exists():
        info(f"Found {env.feats()=}")
    else:
        created = sprun("uv", "venv", env.path)
        info(f"{created.ok=}")

    valid, feats = env.validate()
    if valid:
        outs = f"{env.activate_path}"

    info(f"Env feats: {pformat(feats)}")
    return env, outs


def cli():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("name", help="Environment name")
    args = parser.parse_args()
    env, outs = env_make_activate(args.name)
    tell(outs)
    return env

# cli()
# CompletedProcess(args=['uv', 'venv', '/Users/toni/tk/uv/pygen'], returncode=0, stdout=b'', stderr=b'Using Python 3.11.6 interpreter at: \x1b[36m/Users/toni/miniconda3/envs/research/bin/python3.11\x1b[39m\nCreating virtualenv at: \x1b[36m/Users/toni/tk/uv/pygen\x1b[39m\n')

